{"ast":null,"code":"import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";import _defineProperty from\"@babel/runtime/helpers/defineProperty\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){keys.push.apply(keys,Object.getOwnPropertySymbols(object));}if(enumerableOnly)keys=keys.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(source,true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(source).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}import{useState,useContext,useEffect,useLayoutEffect,useRef,useCallback}from'react';import{NavigationContext}from'react-navigation';export function useNavigation(){var navigation=useContext(NavigationContext);if(!navigation){throw new Error(\"react-navigation hooks require a navigation context but it couldn't be found. \"+\"Make sure you didn't forget to create and render the react-navigation app container. \"+'If you need to access an optional navigation object, you can useContext(NavigationContext), which may return');}return navigation;}export function useNavigationParam(paramName){return useNavigation().getParam(paramName);}export function useNavigationState(){return useNavigation().state;}export function useNavigationKey(){return useNavigation().state.key;}var useGetter=function useGetter(value){var ref=useRef(value);useLayoutEffect(function(){ref.current=value;});return useCallback(function(){return ref.current;},[ref]);};export function useNavigationEvents(callback){var navigation=useNavigation();var getLatestCallback=useGetter(callback);useLayoutEffect(function(){var subscribedCallback=function subscribedCallback(event){var latestCallback=getLatestCallback();latestCallback(event);};var subs=[navigation.addListener('action',subscribedCallback),navigation.addListener('willFocus',subscribedCallback),navigation.addListener('didFocus',subscribedCallback),navigation.addListener('willBlur',subscribedCallback),navigation.addListener('didBlur',subscribedCallback)];return function(){subs.forEach(function(sub){return sub.remove();});};},[navigation.state.key]);}var emptyFocusState={isFocused:false,isBlurring:false,isBlurred:false,isFocusing:false};var didFocusState=_objectSpread({},emptyFocusState,{isFocused:true});var willBlurState=_objectSpread({},emptyFocusState,{isBlurring:true});var didBlurState=_objectSpread({},emptyFocusState,{isBlurred:true});var willFocusState=_objectSpread({},emptyFocusState,{isFocusing:true});function nextFocusState(eventName,currentState){switch(eventName){case'willFocus':return _objectSpread({},willFocusState,{isFocused:currentState.isFocused});case'didFocus':return didFocusState;case'willBlur':return willBlurState;case'didBlur':return didBlurState;default:return currentState;}}export function useFocusState(){var navigation=useNavigation();var _useState=useState(function(){return navigation.isFocused()?didFocusState:didBlurState;}),_useState2=_slicedToArray(_useState,2),focusState=_useState2[0],setFocusState=_useState2[1];useNavigationEvents(function(e){setFocusState(function(currentFocusState){return nextFocusState(e.type,currentFocusState);});});return focusState;}export var useFocusEffect=function useFocusEffect(callback){var navigation=useNavigation();useEffect(function(){var isFocused=false;var cleanup;if(navigation.isFocused()){cleanup=callback();isFocused=true;}var focusSubscription=navigation.addListener('willFocus',function(){if(isFocused){return;}cleanup&&cleanup();cleanup=callback();isFocused=true;});var blurSubscription=navigation.addListener('willBlur',function(){cleanup&&cleanup();cleanup=undefined;isFocused=false;});return function(){cleanup&&cleanup();focusSubscription.remove();blurSubscription.remove();};},[callback,navigation]);};export var useIsFocused=function useIsFocused(){var navigation=useNavigation();var getNavigation=useGetter(navigation);var _useState3=useState(navigation.isFocused),_useState4=_slicedToArray(_useState3,2),focused=_useState4[0],setFocused=_useState4[1];useEffect(function(){var nav=getNavigation();var focusSubscription=nav.addListener('willFocus',function(){return setFocused(true);});var blurSubscription=nav.addListener('willBlur',function(){return setFocused(false);});return function(){focusSubscription.remove();blurSubscription.remove();};},[getNavigation]);return focused;};","map":{"version":3,"sources":["Hooks.ts"],"names":["navigation","useContext","useNavigation","useGetter","ref","useRef","useLayoutEffect","useCallback","getLatestCallback","subscribedCallback","latestCallback","subs","sub","emptyFocusState","isFocused","isBlurring","isBlurred","isFocusing","didFocusState","willBlurState","didBlurState","willFocusState","currentState","focusState","setFocusState","useState","useNavigationEvents","nextFocusState","e","useFocusEffect","useEffect","cleanup","callback","focusSubscription","blurSubscription","useIsFocused","getNavigation","focused","setFocused","nav"],"mappings":"q3BAAA,QAAA,QAAA,CAAA,UAAA,CAAA,SAAA,CAAA,eAAA,CAAA,MAAA,CAAA,WAAA,KAAA,OAAA,CASA,OAAA,iBAAA,KAAA,kBAAA,CAUA,MAAO,SAAA,CAAA,aAAA,EAAuE,CAC5E,GAAMA,CAAAA,UAAU,CAAGC,UAAU,CAA7B,iBAA6B,CAA7B,CACA,GAAI,CAAJ,UAAA,CAAiB,CACf,KAAM,IAAA,CAAA,KAAA,CACJ,iFAAA,uFAAA,CADF,8GAAM,CAAN,CAMF,OAAA,CAAA,UAAA,CAGF,OAAO,SAAA,CAAA,kBAAA,CAAA,SAAA,CAEL,CACA,MAAOC,CAAAA,aAAa,GAAbA,QAAAA,CAAP,SAAOA,CAAP,CAGF,OAAO,SAAA,CAAA,kBAAA,EAA8B,CACnC,MAAOA,CAAAA,aAAa,GAApB,KAAA,CAGF,OAAO,SAAA,CAAA,gBAAA,EAA4B,CACjC,MAAOA,CAAAA,aAAa,GAAbA,KAAAA,CAAP,GAAA,CAIF,IAAMC,CAAAA,SAAS,CAATA,QAAAA,CAAAA,SAAAA,CAAY,KAAZA,CAAwC,CAC5C,GAAMC,CAAAA,GAAG,CAAGC,MAAM,CAAlB,KAAkB,CAAlB,CACAC,eAAe,CAAC,UAAM,CACpBF,GAAG,CAAHA,OAAAA,CAAAA,KAAAA,CADFE,CAAe,CAAfA,CAGA,MAAOC,CAAAA,WAAW,CAAC,UAAA,CAAA,MAAMH,CAAAA,GAAG,CAAT,OAAA,CAAD,CAAA,CAAoB,CAAtC,GAAsC,CAApB,CAAlB,CALF,CAAA,CAQA,MAAO,SAAA,CAAA,mBAAA,CAAA,QAAA,CAAgE,CACrE,GAAMJ,CAAAA,UAAU,CAAGE,aAAnB,EAAA,CAIA,GAAMM,CAAAA,iBAAiB,CAAGL,SAAS,CAAnC,QAAmC,CAAnC,CAOAG,eAAe,CAAC,UAAM,CACpB,GAAMG,CAAAA,kBAA2C,CAA3CA,QAAAA,CAAAA,kBAAAA,CAA8C,KAA9CA,CAAuD,CAC3D,GAAMC,CAAAA,cAAc,CAAGF,iBAAvB,EAAA,CACAE,cAAc,CAAdA,KAAc,CAAdA,CAFF,CAAA,CAKA,GAAMC,CAAAA,IAAI,CAAG,CAEXX,UAAU,CAAVA,WAAAA,CAAAA,QAAAA,CAFW,kBAEXA,CAFW,CAGXA,UAAU,CAAVA,WAAAA,CAAAA,WAAAA,CAHW,kBAGXA,CAHW,CAIXA,UAAU,CAAVA,WAAAA,CAAAA,UAAAA,CAJW,kBAIXA,CAJW,CAKXA,UAAU,CAAVA,WAAAA,CAAAA,UAAAA,CALW,kBAKXA,CALW,CAMXA,UAAU,CAAVA,WAAAA,CAAAA,SAAAA,CANF,kBAMEA,CANW,CAAb,CAQA,MAAO,WAAM,CACXW,IAAI,CAAJA,OAAAA,CAAa,SAAA,GAAA,CAAG,CAAA,MAAIC,CAAAA,GAAG,CAAP,MAAIA,EAAJ,CAAhBD,CAAAA,EADF,CAAA,CAda,CAAA,CAiBZ,CAACX,UAAU,CAAVA,KAAAA,CAjBJM,GAiBG,CAjBY,CAAfA,CA2BF,IAAMO,CAAAA,eAA2B,CAAG,CAClCC,SAAS,CADyB,KAAA,CAElCC,UAAU,CAFwB,KAAA,CAGlCC,SAAS,CAHyB,KAAA,CAIlCC,UAAU,CAJZ,KAAoC,CAApC,CAMA,GAAMC,CAAAA,aAAyB,CAAA,aAAA,CAAA,EAAA,CAAA,eAAA,CAAA,CAAyBJ,SAAS,CAAjE,IAA+B,CAAA,CAA/B,CACA,GAAMK,CAAAA,aAAyB,CAAA,aAAA,CAAA,EAAA,CAAA,eAAA,CAAA,CAAyBJ,UAAU,CAAlE,IAA+B,CAAA,CAA/B,CACA,GAAMK,CAAAA,YAAwB,CAAA,aAAA,CAAA,EAAA,CAAA,eAAA,CAAA,CAAyBJ,SAAS,CAAhE,IAA8B,CAAA,CAA9B,CACA,GAAMK,CAAAA,cAA0B,CAAA,aAAA,CAAA,EAAA,CAAA,eAAA,CAAA,CAAyBJ,UAAU,CAAnE,IAAgC,CAAA,CAAhC,CAEA,QAAA,CAAA,cAAA,CAAA,SAAA,CAAA,YAAA,CAGc,CACZ,OAAA,SAAA,EACE,IAAA,WAAA,CACE,MAAA,CAAA,aAAA,CAAA,EAAA,CAAA,cAAA,CAAA,CAOEH,SAAS,CAAEQ,YAAY,CAPzB,SAAA,CAAA,CAAA,CASF,IAAA,UAAA,CACE,MAAA,CAAA,aAAA,CACF,IAAA,UAAA,CACE,MAAA,CAAA,aAAA,CACF,IAAA,SAAA,CACE,MAAA,CAAA,YAAA,CACF,QAEE,MAnBJ,CAAA,YAmBI,CAnBJ,CAuBF,OAAO,SAAA,CAAA,aAAA,EAAyB,CAC9B,GAAMtB,CAAAA,UAAU,CAAGE,aAAnB,EAAA,CAD8B,GAAA,CAAA,SAAA,CAGMuB,QAAQ,CAAa,UAAM,CAC7D,MAAOzB,CAAAA,UAAU,CAAVA,SAAAA,GAAAA,aAAAA,CAAP,YAAA,CAJ4B,CAGc,CAHd,CAAA,UAAA,CAAA,cAAA,CAAA,SAAA,CAAA,CAAA,CAAA,CAGvBuB,UAHuB,CAAA,UAAA,CAAA,CAAA,CAAA,CAGXC,aAHW,CAAA,UAAA,CAAA,CAAA,CAAA,CAO9BE,mBAAmB,CAAC,SAAA,CAAA,CAA+B,CACjDF,aAAa,CAAC,SAAA,iBAAA,CAAiB,CAAA,MAC7BG,CAAAA,cAAc,CAACC,CAAC,CAAF,IAAA,CADe,iBACf,CADe,CAA/BJ,CAAa,CAAbA,CADFE,CAAmB,CAAnBA,CAMA,MAAA,CAAA,UAAA,CAOF,OAAO,IAAMG,CAAAA,cAAc,CAAdA,QAAAA,CAAAA,cAAAA,CAAiB,QAAjBA,CAA+C,CAC1D,GAAM7B,CAAAA,UAAU,CAAGE,aAAnB,EAAA,CAEA4B,SAAS,CAAC,UAAM,CACd,GAAIhB,CAAAA,SAAS,CAAb,KAAA,CACA,GAAA,CAAA,OAAA,CAEA,GAAId,UAAU,CAAd,SAAIA,EAAJ,CAA4B,CAC1B+B,OAAO,CAAGC,QAAVD,EAAAA,CACAjB,SAAS,CAATA,IAAAA,CAGF,IAAMmB,CAAAA,iBAAiB,CAAGjC,UAAU,CAAVA,WAAAA,CAAAA,WAAAA,CAAoC,UAAM,CAGlE,GAAA,SAAA,CAAe,CACb,OAGF+B,CAAAA,OAAO,EAAIA,OAAXA,EAAAA,CACAA,OAAO,CAAGC,QAAVD,EAAAA,CACAjB,SAAS,CAATA,IAAAA,CATF,CAA0Bd,CAA1B,CAYA,GAAMkC,CAAAA,gBAAgB,CAAGlC,UAAU,CAAVA,WAAAA,CAAAA,UAAAA,CAAmC,UAAM,CAChE+B,OAAO,EAAIA,OAAXA,EAAAA,CACAA,OAAO,CAAPA,SAAAA,CACAjB,SAAS,CAATA,KAAAA,CAHF,CAAyBd,CAAzB,CAMA,MAAO,WAAM,CACX+B,OAAO,EAAIA,OAAXA,EAAAA,CACAE,iBAAiB,CAAjBA,MAAAA,GACAC,gBAAgB,CAAhBA,MAAAA,GAHF,CAAA,CA3BO,CAAA,CAgCN,CAAA,QAAA,CAhCHJ,UAgCG,CAhCM,CAATA,CAHK,CAAA,CAsCP,MAAO,IAAMK,CAAAA,YAAY,CAAZA,QAAAA,CAAAA,YAAAA,EAAqB,CAChC,GAAMnC,CAAAA,UAAU,CAAGE,aAAnB,EAAA,CACA,GAAMkC,CAAAA,aAAa,CAAGjC,SAAS,CAA/B,UAA+B,CAA/B,CAFgC,GAAA,CAAA,UAAA,CAGFsB,QAAQ,CAACzB,UAAU,CAHjB,SAGM,CAHN,CAAA,UAAA,CAAA,cAAA,CAAA,UAAA,CAAA,CAAA,CAAA,CAGzBqC,OAHyB,CAAA,UAAA,CAAA,CAAA,CAAA,CAGhBC,UAHgB,CAAA,UAAA,CAAA,CAAA,CAAA,CAKhCR,SAAS,CAAC,UAAM,CACd,GAAMS,CAAAA,GAAG,CAAGH,aAAZ,EAAA,CACA,GAAMH,CAAAA,iBAAiB,CAAGM,GAAG,CAAHA,WAAAA,CAAAA,WAAAA,CAA6B,UAAA,CAAA,MACrDD,CAAAA,UAAU,CAD2C,IAC3C,CAD2C,CAAvD,CAA0BC,CAA1B,CAGA,GAAML,CAAAA,gBAAgB,CAAGK,GAAG,CAAHA,WAAAA,CAAAA,UAAAA,CAA4B,UAAA,CAAA,MACnDD,CAAAA,UAAU,CADyC,KACzC,CADyC,CAArD,CAAyBC,CAAzB,CAGA,MAAO,WAAM,CACXN,iBAAiB,CAAjBA,MAAAA,GACAC,gBAAgB,CAAhBA,MAAAA,GAFF,CAAA,CARO,CAAA,CAYN,CAZHJ,aAYG,CAZM,CAATA,CAcA,MAAA,CAAA,OAAA,CAnBK,CAAA","sourcesContent":["import {\n  useState,\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useRef,\n  useCallback,\n} from 'react';\n\nimport {\n  NavigationContext,\n  NavigationScreenProp,\n  NavigationRoute,\n  NavigationParams,\n  NavigationEventCallback,\n  NavigationEventPayload,\n  EventType,\n} from 'react-navigation';\n\nexport function useNavigation<S>(): NavigationScreenProp<S & NavigationRoute> {\n  const navigation = useContext(NavigationContext) as any; // TODO typing?\n  if (!navigation) {\n    throw new Error(\n      \"react-navigation hooks require a navigation context but it couldn't be found. \" +\n        \"Make sure you didn't forget to create and render the react-navigation app container. \" +\n        'If you need to access an optional navigation object, you can useContext(NavigationContext), which may return'\n    );\n  }\n  return navigation;\n}\n\nexport function useNavigationParam<T extends keyof NavigationParams>(\n  paramName: T\n) {\n  return useNavigation().getParam(paramName);\n}\n\nexport function useNavigationState() {\n  return useNavigation().state;\n}\n\nexport function useNavigationKey() {\n  return useNavigation().state.key;\n}\n\n// Useful to access the latest user-provided value\nconst useGetter = <S>(value: S): (() => S) => {\n  const ref = useRef(value);\n  useLayoutEffect(() => {\n    ref.current = value;\n  });\n  return useCallback(() => ref.current, [ref]);\n};\n\nexport function useNavigationEvents(callback: NavigationEventCallback) {\n  const navigation = useNavigation();\n\n  // Closure might change over time and capture some variables\n  // It's important to fire the latest closure provided by the user\n  const getLatestCallback = useGetter(callback);\n\n  // It's important to useLayoutEffect because we want to ensure we subscribe synchronously to the mounting\n  // of the component, similarly to what would happen if we did use componentDidMount\n  // (that we use in <NavigationEvents/>)\n  // When mounting/focusing a new screen and subscribing to focus, the focus event should be fired\n  // It wouldn't fire if we did subscribe with useEffect()\n  useLayoutEffect(() => {\n    const subscribedCallback: NavigationEventCallback = event => {\n      const latestCallback = getLatestCallback();\n      latestCallback(event);\n    };\n\n    const subs = [\n      // TODO should we remove \"action\" here? it's not in the published typedefs\n      navigation.addListener('action' as any, subscribedCallback),\n      navigation.addListener('willFocus', subscribedCallback),\n      navigation.addListener('didFocus', subscribedCallback),\n      navigation.addListener('willBlur', subscribedCallback),\n      navigation.addListener('didBlur', subscribedCallback),\n    ];\n    return () => {\n      subs.forEach(sub => sub.remove());\n    };\n  }, [navigation.state.key]);\n}\n\nexport interface FocusState {\n  isFocused: boolean;\n  isBlurring: boolean;\n  isBlurred: boolean;\n  isFocusing: boolean;\n}\n\nconst emptyFocusState: FocusState = {\n  isFocused: false,\n  isBlurring: false,\n  isBlurred: false,\n  isFocusing: false,\n};\nconst didFocusState: FocusState = { ...emptyFocusState, isFocused: true };\nconst willBlurState: FocusState = { ...emptyFocusState, isBlurring: true };\nconst didBlurState: FocusState = { ...emptyFocusState, isBlurred: true };\nconst willFocusState: FocusState = { ...emptyFocusState, isFocusing: true };\n\nfunction nextFocusState(\n  eventName: EventType,\n  currentState: FocusState\n): FocusState {\n  switch (eventName) {\n    case 'willFocus':\n      return {\n        ...willFocusState,\n        // /!\\ willFocus will fire on screen mount, while the screen is already marked as focused.\n        // In case of a new screen mounted/focused, we want to avoid a isFocused = true => false => true transition\n        // So we don't put the \"false\" here and ensure the attribute remains as before\n        // Currently I think the behavior of the event system on mount is not very well specified\n        // See also https://twitter.com/sebastienlorber/status/1166986080966578176\n        isFocused: currentState.isFocused,\n      };\n    case 'didFocus':\n      return didFocusState;\n    case 'willBlur':\n      return willBlurState;\n    case 'didBlur':\n      return didBlurState;\n    default:\n      // preserve current state for other events (\"action\"?)\n      return currentState;\n  }\n}\n\nexport function useFocusState() {\n  const navigation = useNavigation();\n\n  const [focusState, setFocusState] = useState<FocusState>(() => {\n    return navigation.isFocused() ? didFocusState : didBlurState;\n  });\n\n  useNavigationEvents((e: NavigationEventPayload) => {\n    setFocusState(currentFocusState =>\n      nextFocusState(e.type, currentFocusState)\n    );\n  });\n\n  return focusState;\n}\n\ntype EffectCallback = (() => void) | (() => () => void);\n\n// Inspired by same hook from react-navigation v5\n// See https://github.com/react-navigation/hooks/issues/39#issuecomment-534694135\nexport const useFocusEffect = (callback: EffectCallback) => {\n  const navigation = useNavigation();\n\n  useEffect(() => {\n    let isFocused = false;\n    let cleanup: (() => void) | void;\n\n    if (navigation.isFocused()) {\n      cleanup = callback();\n      isFocused = true;\n    }\n\n    const focusSubscription = navigation.addListener('willFocus', () => {\n      // If callback was already called for focus, avoid calling it again\n      // The focus event may also fire on intial render, so we guard against runing the effect twice\n      if (isFocused) {\n        return;\n      }\n\n      cleanup && cleanup();\n      cleanup = callback();\n      isFocused = true;\n    });\n\n    const blurSubscription = navigation.addListener('willBlur', () => {\n      cleanup && cleanup();\n      cleanup = undefined;\n      isFocused = false;\n    });\n\n    return () => {\n      cleanup && cleanup();\n      focusSubscription.remove();\n      blurSubscription.remove();\n    };\n  }, [callback, navigation]);\n};\n\nexport const useIsFocused = () => {\n  const navigation = useNavigation();\n  const getNavigation = useGetter(navigation);\n  const [focused, setFocused] = useState(navigation.isFocused);\n\n  useEffect(() => {\n    const nav = getNavigation();\n    const focusSubscription = nav.addListener('willFocus', () =>\n      setFocused(true)\n    );\n    const blurSubscription = nav.addListener('willBlur', () =>\n      setFocused(false)\n    );\n    return () => {\n      focusSubscription.remove();\n      blurSubscription.remove();\n    };\n  }, [getNavigation]);\n\n  return focused;\n};\n"]},"metadata":{},"sourceType":"module"}